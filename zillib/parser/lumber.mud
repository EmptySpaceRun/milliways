"Stuff from NEW PARSER that's gone but not forgotten"

<PRODUCTION RED-S7A	S 2	(VP PP)>

;<PRODUCTION RED-PRONOUN		NP 7		(PRONOUN)>

;<PRODUCTION RED-S3	S 2	(VP ?PARTICLE NPP PP)>
;<PRODUCTION RED-S3A	S 2	(VP NPP PARTICLE PP)>

;<PRODUCTION RED-S16	S 2	(QWORDS-2 PARTICLE NPP)>

;<PRODUCTION RED-S10	S 2	(QWORDS-12 TOBE-PHRASE NPP ?NOT ?BE)>

;<PRODUCTION RED-FCN	QWORDS-12 3	(QWORD) (QWORDS-2)>

<DEFINE RED-S7A ("OPT" N:FIX TYP:FIX "AUX" PP:PMEM VERB (RES <>))
	<COND (<NOT <ASSIGNED? N>>
	       <IFFLAG (P-DEBUGGING-PARSER <PRINTR "VP-PP">) (T <RFALSE>)>)>
	<SET PP <POP-PSTACK ,DATA-STACK>>
	<SET VERB <POP-PSTACK ,DATA-STACK>>
	;"Start by trying a particle/noun phrase instead of a prep phrase."
	<COND (<AND <WORD-TYPE? <PP-PREP .PP> ,P-PARTICLE-CODE>
		    <PUSH-PSTACK ,DATA-STACK .VERB>
		    <PUSH-PSTACK ,DATA-STACK <PP-PREP .PP>>
		    <PUSH-PSTACK ,DATA-STACK <PP-NOUN .PP>>
		    <SET RES <RED-S2 ;"VP-?P-NP" 3 .TYP>>>
	       .RES)
	      (<AND ;<NOT <EQUAL? <PP-PREP .PP> ,W?BUT ,W?EXCEPT>>
		    <L=? 0 <SET RES <VERB-ZERO <WORD-VERB-STUFF
					<PARSE-VERB ,PARSE-RESULT>>>>:FIX>
		    ;<SET RES <GET-SYNTAX .RES 1 <PP-PREP .PP> ;"?">>>
	       <PARSE-ACTION ,PARSE-RESULT .RES>
	       <COND (<SET RES <REDUCE-LOCATION .PP ;.RES ;1>>
		      <PARSE-LOC ,PARSE-RESULT .RES>)>)>
	;<COND (<TYPE? <SET N1 <HACK-PREP <POP-PSTACK ,DATA-STACK>
					 ,PARSE-RESULT>>
		      LOCATION>
	       <PARSE-LOC ,PARSE-RESULT .N1>
	       <FLUSH-PSTACK ,DATA-STACK 2>
	       <COND (<AND <NOT <NP-QUANT <SET N1 <LOCATION-OBJECT .N1>>>>
			   <G? <LENGTH <NP-OBJECTS .N1>> 1>>
		      <PARSE-ORPHAN-ADJ ,PARSE-RESULT .N1>
		      <PARSE-ORPHAN-LOC ,PARSE-RESULT T>)>
	       ,PARSE-RESULT)>>

;<DEFINE RED-PART RP ("OPT" N:FIX TYP:FIX "AUX" W1 W2)
	<COND (<NOT <ASSIGNED? N>>
	       <IFFLAG (P-DEBUGGING-PARSER <PRINTR "?PART">) (T <RFALSE>)>)>
	<COND (<==? .N 0>
	       <RETURN T .RP>)>
	<SET W2 <POP-PSTACK ,DATA-STACK>>
	<COND (<==? .N 1>	;"just PARTICLE"
	       <RETURN .W2 .RP>)>
	<SET W1 <POP-PSTACK ,DATA-STACK>>
	<COND (<EQUAL? .W2 ,W?OF ,W?FROM ,W?ON>
	       .W1)>>

;<DEFINE RED-PRONOUN ("OPT" N:FIX TYP:FIX
		     "AUX" PRON:VWORD PV (VF <>) PF (OBJ <>))
	<COND (<NOT <ASSIGNED? N>>
	       <IFFLAG (P-DEBUGGING-PARSER <PRINTR "PRONOUN">) (T <RFALSE>)>)>
	<SET PV <PARSE-VERB ,PARSE-RESULT>>
	<SET PRON <POP-PSTACK ,DATA-STACK>>
	<SET PF <WORD-FLAGS .PRON>>
	;<COND (<AND .PV
		     <WORD-TYPE? .PV ,P-TOBE-CODE>>
	       <SET VF <WORD-FLAGS .PV>>)>
	<COND (<AND <T? <ANDB .PF ,FIRST-PERSON>>
		    <F? <ANDB .PF ,PLURAL-FLAG>>>
	       <COND (T ;<OR <NOT .VF>
			  <N==? <ANDB .VF ,FIRST-PERSON-SINGULAR> 0>>
		      <SET OBJ <PMEM-ALLOC NOUN-PHRASE
				 COUNT 1
				 LENGTH ,NOUN-PHRASE-MIN-LENGTH
				 OBJ1 ,PLAYER
				 NP1 <PMEM-ALLOC NP NAME .PRON
						    LEXBEG ,TLEXV
						    LEXEND ,TLEXV>>>)>)
	      ;(<AND <T? <ANDB .PF ,FIRST-PERSON>>
		    <T? <ANDB .PF ,PLURAL-FLAG>>>
	       <COND (T ;<OR <NOT .VF>
			  <N==? <ANDB .VF ,FIRST-PERSON-PLURAL> 0>>
		      <SET OBJ <PMEM-ALLOC NOUN-PHRASE
				 COUNT 2
				 LENGTH <+ 2 ,NOUN-PHRASE-MIN-LENGTH>
				 OBJ1 ,PLAYER
				 NP1 <PMEM-ALLOC NP NAME .PRON
						    LEXBEG ,TLEXV
						    LEXEND ,TLEXV>
				 OBJ2 ,WINNER
				 NP2 .NP1>>)>)
	      (<N==? 0 <ANDB .PF ,SECOND-PERSON>>
	       <COND (T ;<OR <NOT .VF>
			  <N==? <ANDB .VF ,SECOND-PERSON> 0>>
		      <SET OBJ <PMEM-ALLOC NOUN-PHRASE
				 COUNT 1
				 LENGTH ,NOUN-PHRASE-MIN-LENGTH
				 OBJ1 <OR<PARSE-CHOMPER ,PARSE-RESULT> ,PLAYER>
				 NP1 <PMEM-ALLOC NP NAME .PRON
						    LEXBEG ,TLEXV
						    LEXEND ,TLEXV>>>)>)
	      (<AND <T? <ANDB .PF ,THIRD-PERSON>>
		    <F? <ANDB .PF ,PLURAL-FLAG>>>
	       <COND (T ;<OR <NOT .VF>
			  <N==? <ANDB .VF ,THIRD-PERSON-SINGULAR> 0>>
		      <COND (<EQUAL? .PRON ,W?IT>
			     <SET OBJ ,P-IT-OBJECT>)
			    (<EQUAL? .PRON ,W?HER>
			     <SET OBJ ,P-HER-OBJECT>)
			    (<EQUAL? .PRON ,W?HIM>
			     <SET OBJ ,P-HIM-OBJECT>)>)>)
	      ;(<AND <T? <ANDB .PF ,THIRD-PERSON>>
		    <T? <ANDB .PF ,PLURAL-FLAG>>>
	       <COND (T ;<OR <NOT .VF>
			  <N==? <ANDB .VF ,THIRD-PERSON-PLURAL> 0>>
		      <COND (<EQUAL? .PRON ,W?THEM>
			     <SET OBJ ,P-THEM-OBJECT>)>)>)>
	.OBJ>

;<DEFINE RED-DET ("OPT" N:FIX TYP:FIX "AUX" E)
  <COND (<NOT <ASSIGNED? N>>
	 <IFFLAG (P-DEBUGGING-PARSER <PRINTR "DET">) (T <RFALSE>)>)>
  <COND (<0? .N> T)
	(<EQUAL? <SET E <POP-PSTACK ,DATA-STACK>>
		 ,W?THE ,W?A ,W?AN>
	 .E)>>

;<DEFINE RED-S3 ("OPT" N:FIX TYP:FIX
	        "AUX" OBJ RLOC:PMEM N1:PMEM NV PART DATA:VERB-DATA VA SYN)
	<COND (<NOT <ASSIGNED? N>>
	       <IFFLAG (P-DEBUGGING-PARSER <PRINTR "VP-?P-NP-PP">)
		       (T <RFALSE>)>)>
	<SET RLOC <POP-PSTACK ,DATA-STACK>>
	<SET N1 <POP-PSTACK ,DATA-STACK>>
	<SET PART <POP-PSTACK ,DATA-STACK>>
	;<PARSE-PARTICLE1 ,PARSE-RESULT .PART>
	<COND
	 (<SET NV <PARSE-VERB ;GET-PARSE-VERB ,PARSE-RESULT>>
	  ;"Have a verb"
	  <SET DATA <WORD-VERB-STUFF .NV>>
	  <COND
	   (<NOT <SET VA <VERB-TWO .DATA>>>
	    <PARSER-ERROR 0 ,PARSER-ERROR-TMNOUN ;,P-TOO-MANY-ARGS-TO-VERB>)
	   (<NOT <SET SYN <GET-SYNTAX .VA 2 ;.DATA <PP-PREP .RLOC> T>>>
	    <PARSER-ERROR 0 ;"No syntax" ,PARSER-ERROR-NOUND>)
	   (<NOT <SET OBJ <DETERMINE-OBJ .N1 1>>>
	    <PARSER-ERROR 0 ,PARSER-ERROR-NOOBJ .OBJ
			  <SYNTAX-SEARCH ;B9 .SYN 2>>)
	   (<SET RLOC <REDUCE-LOCATION .RLOC .SYN 2>>
		;"Prep has to be something we can use as a second arg"
	    <FLUSH-PSTACK ,DATA-STACK <- .N 3>>
	    <PARSE-OBJ1 ,PARSE-RESULT .OBJ>
	    <PARSE-LOC ,PARSE-RESULT .RLOC>
	    <PARSE-OBJ2 ,PARSE-RESULT <LOCATION-OBJECT .RLOC>>
	    ;<COND (<AND <NOT <NP-QUANT .N1>>
			<G? <LENGTH <NP-OBJECTS .N1>> 1>>
		   <PARSE-ORPHAN-NOUN ,PARSE-RESULT T>
		   <PARSE-ORPHAN-ADJ ,PARSE-RESULT .N1>)>
	    <COND (<AND ;<NOT <NP-QUANT <SET N1 <LOC-OBJECT .RLOC>>>>
			;<G? <LENGTH <NP-OBJECTS .N1>> 1>
			<G? <NOUN-PHRASE-COUNT <LOCATION-OBJECT .RLOC>>:FIX 1>>
		   <PARSE-ORPHAN-LOC ,PARSE-RESULT T>
		   <OR <PARSE-ORPHAN-ADJ ,PARSE-RESULT>
		       <PARSE-ORPHAN-ADJ ,PARSE-RESULT .N1>>)>
	    ,PARSE-RESULT)>)>>

"This is the other S3 case, so just shuffle things first..."
;<DEFINE RED-S3A ("OPT" N:FIX TYP:FIX "AUX" RLOC PART N1)
	<COND (<NOT <ASSIGNED? N>>
	       <IFFLAG (P-DEBUGGING-PARSER <PRINTR "VP-NP-P-PP">)
		       (T <RFALSE>)>)>
	<SET RLOC <POP-PSTACK ,DATA-STACK>>
	<SET PART <POP-PSTACK ,DATA-STACK>>
	<SET N1 <POP-PSTACK ,DATA-STACK>>
	<PUSH-PSTACK ,DATA-STACK .PART>
	<PUSH-PSTACK ,DATA-STACK .N1>
	<PUSH-PSTACK ,DATA-STACK .RLOC>
	<RED-S3 .N .TYP>>

;<DEFINE RED-S16 ("OPT" N:FIX TYP:FIX "AUX" OBJ PART QWD)
	<COND (<NOT <ASSIGNED? N>>
	       <IFFLAG (P-DEBUGGING-PARSER <PRINTR "Q2-P-NPP">) (T <RFALSE>)>)>
	<SET OBJ <POP-PSTACK ,DATA-STACK>>
	<SET PART <POP-PSTACK ,DATA-STACK>>
	<SET QWD <POP-PSTACK ,DATA-STACK>>
	<COND (<AND <=? <CHTYPE <WORD-LEXICAL-WORD .PART> STRING> "ABOUT">
		    <=? <CHTYPE <WORD-LEXICAL-WORD .QWD> STRING> "WHAT">>
	       <PARSE-VERB ,PARSE-RESULT ,W?WHAT.ABOUT>
	       <COND (<SET OBJ <DETERMINE-OBJ .OBJ 1>>
		      <PARSE-OBJ1 ,PARSE-RESULT .OBJ>
		      ,PARSE-RESULT)>)>>

;<DEFINE RED-NP5 ("OPT" N:FIX TYP:FIX "AUX" NP:PMEM ;PNP:PMEM)
	<COND (<NOT <ASSIGNED? N>>
	       <IFFLAG (P-DEBUGGING-PARSER <PRINTR "POSS-NP">) (T <RFALSE>)>)>
	<SET NP <POP-PSTACK ,DATA-STACK>>
	<NP-OWNER .NP <POP-PSTACK ,DATA-STACK>>
	.NP>

;<DEFINE RED-S10 ("OPT" N:FIX TYP:FIX "AUX" (PR ,PARSE-RESULT) (S ,DATA-STACK)
		  N1 (VERB <PARSE-VERB ,PARSE-RESULT>))
	<COND (<NOT <ASSIGNED? N>>
	       <IFFLAG (P-DEBUGGING-PARSER <PRINTR "Q12-BP-NPP-?B">)
		       (T <RFALSE>)>)>
	<COND (<COND (<N==? <ANDB <WORD-FLAGS .VERB> ,FUTURE-TENSE> 0>
		      <N==? <POP-PSTACK .S> T>)
		     (<==? <POP-PSTACK .S> T>)>
	       <COND (<N==? <POP-PSTACK .S> T>
		      <PARSE-FLAGS ,PARSE-RESULT
				<ORB <PARSE-FLAGS ,PARSE-RESULT> ,PARSE-NOT>>)>
	       <COND (<AND <NOT <NP-QUANT
				 <SET N1 <DETERMINE-OBJ
					  <POP-PSTACK .S> 1>>>>
			   <G? <LENGTH <NP-OBJECTS .N1>> 1>>
		      <PARSE-ORPHAN-ADJ ,PARSE-RESULT .N1>
		      <PARSE-ORPHAN-NOUN ,PARSE-RESULT T>)>
	       <PARSE-OBJ1 ,PARSE-RESULT .N1>
	       <FLUSH-PSTACK .S 1>
	       <PARSE-QW ,PARSE-RESULT <POP-PSTACK .S>>
	       <PARSE-FLAGS ,PARSE-RESULT
			    <ORB <PARSE-FLAGS ,PARSE-RESULT> ,PARSE-QUESTION>>
	       ,PARSE-RESULT)>>
