"BREDS file: adds verb BE to parser.
Copyright (C) 1988 Infocom, Inc.  All rights reserved."

<ZZPACKAGE "reds">

<ENTRY	RED-BE-FORM RED-BE RED-NOT RED-SNBN RED-SNBA RED-SNBP RED-SNBAP
	RED-CANDO>

<INCLUDE "basedefs" "find" "pbitdefs" "pdefs">

<USE ;"NEWSTRUC" "parser" "pmem" "pstack">

<FILE-FLAGS MDL-ZIL? ;ZAP-TO-SOURCE-DIRECTORY?>

<BEGIN-SEGMENT 0>

<NEW-ADD-WORD "AM" TOBE <> <ORB ,FIRST-PERSON ,PRESENT-TENSE>>
<NEW-ADD-WORD "ARE" TOBE <> <ORB ,FIRST-PERSON ,SECOND-PERSON ,THIRD-PERSON
				  ,PRESENT-TENSE ,PLURAL-FLAG>>
<NEW-ADD-WORD "IS" TOBE <> <ORB ,THIRD-PERSON ,PRESENT-TENSE>>

<NEW-ADD-WORD "WAS" TOBE <> <ORB ,FIRST-PERSON ,THIRD-PERSON ,PAST-TENSE>>
<NEW-ADD-WORD "WERE" TOBE <> <ORB ,FIRST-PERSON ,SECOND-PERSON ,THIRD-PERSON
				   ,PAST-TENSE ,PLURAL-FLAG>>
<NEW-ADD-WORD "WILL" TOBE <> ,FUTURE-TENSE>
<NEW-ADD-WORD "SHALL" TOBE <> ,FUTURE-TENSE>

<ADD-WORD "HOW" QWORD>
<ADD-WORD "WHAT" QWORD>
<ADD-WORD "WHEN" QWORD>
<ADD-WORD "WHERE" QWORD>
<ADD-WORD "WHO" QWORD>
;<ADD-WORD "WHOM" QWORD>
<ADD-WORD "WHY" QWORD>

<DEFINE RED-BE-FORM ("OPT" N:FIX TYP:FIX)
	;<COND (<NOT <ASSIGNED? N>>
	       <IFFLAG (P-DEBUGGING-PARSER <PRINTR "BE">) (T <RFALSE>)>)>
	<PARSE-VERB-LEXV ,PARSE-RESULT ,TLEXV>
	<PARSE-VERB ,PARSE-RESULT <POP-PSTACK ,DATA-STACK>>>

<DEFINE EXCH-4-5-Q (RED N TYP "AUX" X1 X2 X3 X4 X5)
	<SET X1 <POP-PSTACK ,DATA-STACK>>
	<SET X2 <POP-PSTACK ,DATA-STACK>>
	<SET X3 <POP-PSTACK ,DATA-STACK>>
	<SET X4 <POP-PSTACK ,DATA-STACK>>
	<SET X5 <POP-PSTACK ,DATA-STACK>>
	<COND (<EQUAL? .N 6>
	       <SET N <- .N 1>>
	       <PARSE-QW ,PARSE-RESULT <POP-PSTACK ,DATA-STACK>>)
	      (T
	       <PARSE-QW ,PARSE-RESULT 0>)>
	<COND (<PMEM? .X3>
	       <PUSH-PSTACK ,DATA-STACK .X3>)
	      (T
	       <PUSH-PSTACK ,DATA-STACK .X4>)>
	<PUSH-PSTACK ,DATA-STACK .X5>
	<COND (<PMEM? .X3>
	       <PUSH-PSTACK ,DATA-STACK .X4>)
	      (T
	       <PUSH-PSTACK ,DATA-STACK .X3>)>
	<PUSH-PSTACK ,DATA-STACK .X2>
	<PUSH-PSTACK ,DATA-STACK .X1>
	<PARSE-FLAGS ,PARSE-RESULT
		     <ORB ,PARSE-QUESTION <PARSE-FLAGS ,PARSE-RESULT>>>
	<ZAPPLY .RED .N .TYP>>

<DEFINE RED-SBNN ("OPT" N:FIX TYP:FIX)
	;<COND (<NOT <ASSIGNED? N>>
	       <IFFLAG (P-DEBUGGING-PARSER <PRINTR "?Q-BE-NP-?N-?B-NPP">)
		       (T <RFALSE>)>)>
	<EXCH-4-5-Q ,RED-SNBN .N .TYP>>

<DEFINE RED-SNBN ("OPT" N:FIX TYP:FIX "AUX"
		 (OK <>) NPP OBJ (VERB <PARSE-VERB ,PARSE-RESULT>))
 ;<COND (<NOT <ASSIGNED? N>>
	<IFFLAG (P-DEBUGGING-PARSER <PRINTR "NP-BE-?N-?B-NPP">) (T <RFALSE>)>)>
 <SET NPP <POP-PSTACK ,DATA-STACK>>
 <COND (<T? <ANDB ,FUTURE-TENSE <WORD-FLAGS .VERB>>>
	<COND (<N==? T <POP-PSTACK ,DATA-STACK>>
	       <SET OK T>)>)
       (T
	<COND (<==? T <POP-PSTACK ,DATA-STACK>>
	       <SET OK T>)>)>
 <COND (.OK
	<COND (<DETERMINE-SUBJ .VERB>
	       <COND (<NOT <SET OBJ <DETERMINE-OBJ .NPP 2>>>
		      <PARSER-ERROR 0 ,PARSER-ERROR-NOOBJ .NPP
			;<SYNTAX-SEARCH <PARSE-SYNTAX ,PARSE-RESULT> 2>>)
		     (<COMPARE-WORD-TYPES <WCN <NP-NAME
						<NOUN-PHRASE-NP1
						 <PARSE-OBJ1 ,PARSE-RESULT>>>>
					  <GET-CLASSIFICATION QWORD>>
		      ;<WORD-TYPE? <NP-NAME <NOUN-PHRASE-NP1
					    <PARSE-OBJ1 ,PARSE-RESULT>>>
				  ,P-QW1-CODE>	;"WHO IS WOMAN"
		      <>)
		     (T
		      <PARSE-OBJ2 ,PARSE-RESULT .OBJ>
		      ,PARSE-RESULT)>)>)>>

<DEFINE DETERMINE-SUBJ (VERB "OPT" (SHORT <>) (N1 <>) "AUX" DATA TMP OBJ1)
  <COND (<AND <NOT .SHORT>
	      <N==? T <POP-PSTACK ,DATA-STACK>>>
	 <PARSE-FLAGS ,PARSE-RESULT
		      <ORB ,PARSE-NOT <PARSE-FLAGS ,PARSE-RESULT>>>)>
  <POP-PSTACK ,DATA-STACK>	;"verb"
  <COND (.SHORT
	 <SET TMP <POP-PSTACK ,DATA-STACK>>
	 <PARSE-QW ,PARSE-RESULT .TMP>)
	(T
	 <SET TMP <PARSE-QW ,PARSE-RESULT>>)>
  <COND (<OR <EQUAL? .TMP 0 1>
	     <NOT <COMPARE-WORD-TYPES <WCN .TMP>
				      <GET-CLASSIFICATION QWORD>>>
	     ;<NOT <WORD-TYPE? .TMP ,P-QW1-CODE>>>
	 <COND (<T? <ANDB ,PARSE-QUESTION <PARSE-FLAGS ,PARSE-RESULT>>>
		<SET TMP ,W?BE?>)
	       (T
		<SET TMP ,W?BE>)>)>
  <SET DATA <WORD-VERB-STUFF .TMP>>
  <COND (<NOT <SET TMP <COND (.SHORT <VERB-ONE .DATA>) (T <VERB-TWO .DATA>)>>>
	 <PARSER-ERROR 0 ,PARSER-ERROR-TMNOUN>)
	(<NOT <SET TMP <GET-SYNTAX .TMP 1 1>>>
	 <PARSER-ERROR 0 ,PARSER-ERROR-NOUND>)
	(<NOT <SET OBJ1 <DETERMINE-OBJ <OR .N1
					   <SET N1 <POP-PSTACK ,DATA-STACK>>>
				       1>>>
	 <PARSER-ERROR 0 ,PARSER-ERROR-NOOBJ .N1
		;<SYNTAX-SEARCH <PARSE-SYNTAX ,PARSE-RESULT> 1>>)
	(T
	 <PARSE-OBJ1 ,PARSE-RESULT .OBJ1>
	 <PARSE-ACTION ,PARSE-RESULT <SYNTAX-ID .TMP>>
	 T)>>

<DEFINE RED-SBNA ("OPT" N:FIX TYP:FIX)
	;<COND (<NOT <ASSIGNED? N>>
	       <IFFLAG (P-DEBUGGING-PARSER <PRINTR "?Q-BE-NP-?N-?B-ADJ">)
		       (T <RFALSE>)>)>
	<EXCH-4-5-Q ,RED-SNBA .N .TYP>>

<DEFINE RED-SNBA ("OPT" N:FIX TYP:FIX "AUX"
		 (OK <>) ADJ (VERB <PARSE-VERB ,PARSE-RESULT>))
 ;<COND (<NOT <ASSIGNED? N>>
	<IFFLAG (P-DEBUGGING-PARSER <PRINTR "NP-BE-?N-?B-ADJ">) (T <RFALSE>)>)>
 <SET ADJ <POP-PSTACK ,DATA-STACK>>
 <COND (<T? <ANDB ,FUTURE-TENSE <WORD-FLAGS .VERB>>>
	<COND (<N==? T <POP-PSTACK ,DATA-STACK>>
	       <SET OK T>)>)
       (T
	<COND (<==? T <POP-PSTACK ,DATA-STACK>>
	       <SET OK T>)>)>
 <COND (.OK
	<COND (<DETERMINE-SUBJ .VERB>
	       <COND (<COMPARE-WORD-TYPES <WCN <NP-NAME
						<NOUN-PHRASE-NP1
						 <PARSE-OBJ1 ,PARSE-RESULT>>>>
					  <GET-CLASSIFICATION QWORD>>
		      ;<WORD-TYPE? <NP-NAME <NOUN-PHRASE-NP1
					    <PARSE-OBJ1 ,PARSE-RESULT>>>
				  ,P-QW1-CODE>	;"WHO IS RED"
		      <>)
		     (T
		      <PARSE-OBJ2 ,PARSE-RESULT
			   <PMEM-ALLOC NOUN-PHRASE
				       COUNT 1
				       LENGTH ,NOUN-PHRASE-MIN-LENGTH
				       OBJ1 ,INTADJ>>
		      <PARSE-ADJ ,PARSE-RESULT .ADJ>
		      ,PARSE-RESULT)>)>)>>

<OBJECT INTADJ
	(LOC GLOBAL-OBJECTS)
	(DESC "adjective")
	(SYNONYM L.G ;"must have one!")>

<DEFINE RED-SBNP ("OPT" N:FIX TYP:FIX)
	;<COND (<NOT <ASSIGNED? N>>
	       <IFFLAG (P-DEBUGGING-PARSER <PRINTR "?Q-BE-NP-?N-?B-PP">)
		       (T <RFALSE>)>)>
	<EXCH-4-5-Q ,RED-SNBP .N .TYP>>

<DEFINE RED-SNBP ("OPT" N:FIX TYP:FIX "AUX"
		 (OK <>) PP (VERB <PARSE-VERB ,PARSE-RESULT>))
 ;<COND (<NOT <ASSIGNED? N>>
	<IFFLAG (P-DEBUGGING-PARSER <PRINTR "NP-BE-?N-?B-PP">) (T <RFALSE>)>)>
 <SET PP <POP-PSTACK ,DATA-STACK>>
 <COND (<T? <ANDB ,FUTURE-TENSE <WORD-FLAGS .VERB>>>
	<COND (<N==? T <POP-PSTACK ,DATA-STACK>>
	       <SET OK T>)>)
       (T
	<COND (<==? T <POP-PSTACK ,DATA-STACK>>
	       <SET OK T>)>)>
 <COND (<AND ;<TYPE? .PP LOCATION>
	     .OK>
	<COND (<DETERMINE-SUBJ .VERB>
	       <COND (<COMPARE-WORD-TYPES <WCN <NP-NAME
						<NOUN-PHRASE-NP1
						 <PARSE-OBJ1 ,PARSE-RESULT>>>>
					  <GET-CLASSIFICATION QWORD>>
		      ;<WORD-TYPE? <NP-NAME <NOUN-PHRASE-NP1
					    <PARSE-OBJ1 ,PARSE-RESULT>>>
				  ,P-QW1-CODE>	;"WHO IS ON FIRST"
		      <>)
		     (T
		      <PARSE-OBJ2 ,PARSE-RESULT
			   <PMEM-ALLOC NOUN-PHRASE
				       COUNT 1
				       LENGTH ,NOUN-PHRASE-MIN-LENGTH
				       OBJ1 ,INTPP>>
		      <COND (<SET OK <REDUCE-LOCATION .PP
					       <PARSE-SYNTAX ;3 ,PARSE-RESULT>
					       2>>
			     <PARSE-LOC ,PARSE-RESULT .OK>)
			    (T
			     <PARSE-LOC ,PARSE-RESULT .PP>)>
		      ,PARSE-RESULT)>)>)>>

;<DEFINE RED-SBNAP ("OPT" N:FIX TYP:FIX)
	;<COND (<NOT <ASSIGNED? N>>
	       <IFFLAG (P-DEBUGGING-PARSER <PRINTR "?Q-BE-NP-?N-?B-PP">)
		       (T <RFALSE>)>)>
	<EXCH-4-5-Q ,RED-SNBAP .N .TYP>>

<DEFINE RED-SNBAP ("OPT" N:FIX TYP:FIX "AUX"
		  (OK <>) ADJ PP (VERB <PARSE-VERB ,PARSE-RESULT>))
 <SET PP <POP-PSTACK ,DATA-STACK>>
 <SET ADJ <POP-PSTACK ,DATA-STACK>>
 <COND (<T? <ANDB ,FUTURE-TENSE <WORD-FLAGS .VERB>>>
	<COND (<N==? T <POP-PSTACK ,DATA-STACK>>
	       <SET OK T>)>)
       (T
	<COND (<==? T <POP-PSTACK ,DATA-STACK>>
	       <SET OK T>)>)>
 <COND (<AND ;<TYPE? .PP LOCATION>
	     .OK>
	<COND (<DETERMINE-SUBJ .VERB>
	       <COND (<COMPARE-WORD-TYPES <WCN <NP-NAME
						<NOUN-PHRASE-NP1
						 <PARSE-OBJ1 ,PARSE-RESULT>>>>
					  <GET-CLASSIFICATION QWORD>>
		      ;<WORD-TYPE? <NP-NAME <NOUN-PHRASE-NP1
					    <PARSE-OBJ1 ,PARSE-RESULT>>>
				  ,P-QW1-CODE>	;"WHO IS MAD AT ME"
		      <>)
		     (T
		      <SET OK
			   <PMEM-ALLOC NOUN-PHRASE
				       COUNT 1 ;2
				       LENGTH <+ 0 ;2 ,NOUN-PHRASE-MIN-LENGTH>
				       OBJ1 ,INTPP>>
		      ;<ZPUT <REST-TO-SLOT .OK NOUN-PHRASE-OBJ1> 2 ,INTADJ>
		      <PARSE-OBJ2 ,PARSE-RESULT .OK>
		      <COND (<SET OK <REDUCE-LOCATION .PP
					       <PARSE-SYNTAX ;3 ,PARSE-RESULT>
					       2>>
			     <PARSE-LOC ,PARSE-RESULT .OK>)
			    (T
			     <COND (<SET OK <DETERMINE-OBJ <PP-NOUN .PP>>>
				    <PP-NOUN .PP .OK>
				    <PUTB .PP 1 ,PMEM-TYPE-LOCATION>)>
			     <PARSE-LOC ,PARSE-RESULT .PP>)>
		      <PARSE-ADJ ,PARSE-RESULT .ADJ>
		      ,PARSE-RESULT)>)>)>>

<DEFINE P-PP-OBJ ("AUX" TMP)
 <COND (<AND <T? <SET TMP <PARSE-LOC ,PARSE-RESULT>>>
	     <PMEM-TYPE? .TMP LOCATION>
	     <T? <SET TMP <LOCATION-OBJECT .TMP>>>>
	<NOUN-PHRASE-OBJ1 .TMP>)>>

<DEFINE P-PP-PREP ("AUX" TMP)
 <COND (<T? <SET TMP <PARSE-LOC ,PARSE-RESULT>>>
	<PP-PREP .TMP>)>>

<OBJECT INTPP
	(LOC GLOBAL-OBJECTS)
	(DESC "prep phrase")
	(SYNONYM L.G ;"must have one!")>

<DEFINE RED-SQBN ("OPT" N:FIX TYP:FIX)
	;<COND (<NOT <ASSIGNED? N>>
	       <IFFLAG (P-DEBUGGING-PARSER <PRINTR "QW1-BE-NP">)
		       (T <RFALSE>)>)>
	<COND (<DETERMINE-SUBJ <PARSE-VERB ,PARSE-RESULT>
			       T
			       <POP-PSTACK ,DATA-STACK>>
	       ,PARSE-RESULT)>>

<DEFINE RED-BE ("OPT" N:FIX TYP:FIX "AUX" E)
  ;<COND (<NOT <ASSIGNED? N>>
	 <IFFLAG (P-DEBUGGING-PARSER <PRINTR "?B">) (T <RFALSE>)>)>
  <COND (<1? .N>
	 <COND (<==? ,W?BE <SET E <POP-PSTACK ,DATA-STACK>>>
		.E)>)
	(T T)>>

<DEFINE RED-NOT ("OPT" N:FIX TYP:FIX "AUX" E)
  ;<COND (<NOT <ASSIGNED? N>>
	 <IFFLAG (P-DEBUGGING-PARSER <PRINTR "?N">) (T <RFALSE>)>)>
  <COND (<1? .N>
	 <COND (<==? ,W?NOT <SET E <POP-PSTACK ,DATA-STACK>>>
		.E)>)
	(T T)>>

<NEW-ADD-WORD "CAN" CANDO <> ;,PRESENT-TENSE>
<NEW-ADD-WORD "COULD" CANDO <> ;,PRESENT-TENSE ;,PAST-TENSE>
<NEW-ADD-WORD "DO" CANDO <> ;,PRESENT-TENSE>
<NEW-ADD-WORD "DOES" CANDO <VOC "DO"> <ORB ,THIRD-PERSON ;,PRESENT-TENSE>>
<NEW-ADD-WORD "DID" CANDO <VOC "DO"> ,PAST-TENSE>
<NEW-ADD-WORD "MAY" CANDO <> ;,PRESENT-TENSE>
<NEW-ADD-WORD "MIGHT" CANDO <> ;,PRESENT-TENSE ;,PAST-TENSE>
<NEW-ADD-WORD "WILL" CANDO <> ;,FUTURE-TENSE>
<NEW-ADD-WORD "SHALL" CANDO <VOC "WILL"> ,FUTURE-TENSE>
;<SYNONYM WILL SHALL>
<NEW-ADD-WORD "WOULD" CANDO <> ;,PRESENT-TENSE ;,PAST-TENSE>
<NEW-ADD-WORD "SHOULD" CANDO <> ;,PRESENT-TENSE ;,PAST-TENSE>
<NEW-ADD-WORD "MUST" CANDO <>>
;<NEW-ADD-WORD "OUGHT" CANDO <>>

<DEFINE RED-CANDO ("OPT" N:FIX TYP:FIX "AUX" TMP OBJ SUBJ)
 <COND (<==? .N 0>
	T)
       (<==? .N 1>
	<SET SUBJ <POP-PSTACK ,DATA-STACK>>
	<COND (<NOT <COMPARE-WORD-TYPES <WCN <NP-NAME .SUBJ>>
					<GET-CLASSIFICATION QWORD>>>
	       ;<NOT <WORD-TYPE? <NP-NAME .SUBJ> ,P-QW1-CODE>>
	       ;<HACK-TELL .SUBJ>
	       <COND (<NOT <SET OBJ <DETERMINE-OBJ .SUBJ>>>
		      <PARSER-ERROR 0 ,PARSER-ERROR-NOOBJ .SUBJ
				    ;<PARSE-SYNTAX ,PARSE-RESULT>>)
		     (<AND <1? <NOUN-PHRASE-COUNT .OBJ>>
			   <FSET? <NOUN-PHRASE-OBJ1 .OBJ> ,PERSONBIT>>
		      <PARSE-SUBJ ,PARSE-RESULT .OBJ>
		      ;<PARSE-ACTION ,PARSE-RESULT <SYNTAX-ID .TMP>>
		      ;<PARSE-QUERY-SYNTAX ,PARSE-RESULT .TMP>
		      T)>)>)
       (T
	<COND (<PMEM? <SET SUBJ <POP-PSTACK ,DATA-STACK>>>
	       <POP-PSTACK ,DATA-STACK>
	       <PARSE-FLAGS ,PARSE-RESULT
			    <ORB ,PARSE-NOT <PARSE-FLAGS ,PARSE-RESULT>>>)
	      (T
	       <COND (<N==? T .SUBJ>
		      <PARSE-FLAGS ,PARSE-RESULT
				   <ORB ,PARSE-NOT
					<PARSE-FLAGS ,PARSE-RESULT>>>)>
	       <SET SUBJ <POP-PSTACK ,DATA-STACK>>
	       <COND (<==? .N 3>
		      <PARSE-QUERY ,PARSE-RESULT .SUBJ>)>)>
	<SET TMP <POP-PSTACK ,DATA-STACK>>
	<COND (<==? .N 3>
	       <SET SUBJ .TMP>
	       <SET TMP <PARSE-QUERY ,PARSE-RESULT>>)
	      (T
	       <PARSE-FLAGS ,PARSE-RESULT
			    <ORB ,PARSE-QUESTION <PARSE-FLAGS ,PARSE-RESULT>>>
	       <PARSE-QUERY ,PARSE-RESULT .TMP>)>
	<COND (<AND <NOT <COMPARE-WORD-TYPES <WCN .TMP>
					     <GET-CLASSIFICATION VERB>>>
		    ;<NOT <WORD-TYPE? .TMP ,P-VERB-CODE>>
		    <SET OBJ <WORD-SEMANTIC-STUFF .TMP>>>
	       <SET TMP .OBJ>)>		;"root form of verb"
	<COND (<NOT <SET TMP <VERB-ONE <WORD-VERB-STUFF .TMP>>>>
	       <PARSER-ERROR 0 ,PARSER-ERROR-TMNOUN>)
	      (<NOT <SET TMP <GET-SYNTAX .TMP 1 1>>>
	       <PARSER-ERROR 0 ,PARSER-ERROR-NOUND>)
	      (<NOT <SET OBJ <DETERMINE-OBJ .SUBJ 1>>>
	       <PARSER-ERROR 0 ,PARSER-ERROR-NOOBJ .SUBJ ;.TMP>)
	      (T
	       <PARSE-SUBJ ,PARSE-RESULT .OBJ>
	       ;<PARSE-ACTION ,PARSE-RESULT <SYNTAX-ID .TMP>>
	       <PARSE-QUERY-SYNTAX ,PARSE-RESULT .TMP>
	       <COND (<==? .N 3>
		      <RTRUE>)>
	       <SET TMP <POP-PSTACK ,DATA-STACK>>
	       <PARSE-QW ,PARSE-RESULT <COND (<N==? T .TMP> .TMP)>>
	       <COND (<EQUAL? .TMP ,W?WHAT ,W?WHO>	;"WHAT CAN I EAT?"
		      <SET SUBJ <INTBL? ,W?PERIOD ,TLEXV ,P-LEN *204*>>
		      <COND (<ZERO? .SUBJ>
			     <SET SUBJ <INTBL? ,W?THEN ,TLEXV ,P-LEN *204*>>)>
		      <COND (<ZERO? .SUBJ>
			     <SET SUBJ <INTBL? ,W?? ,TLEXV ,P-LEN *204*>>)>
		      <COND (<ZERO? .SUBJ>
			     <SET SUBJ <ZREST ,TLEXV <* <- ,P-LEN 1>
							<* 2 ,P-LEXELEN>>>>)>
		      <REPEAT (WD (END <* 2 ,P-LEXELEN>))
			<COND (<EQUAL? .TMP <SET WD <ZGET .SUBJ 0>>>
			       <RTRUE>)
			      (<COMPARE-WORD-TYPES <WCN .WD>
						   <GET-CLASSIFICATION VERB>>
			       ;<WORD-TYPE? .WD ,P-VERB-CODE>
			       <INSERT-WHAT .TMP
					    <ZREST .SUBJ <* 2 ,P-LEXELEN>>>
			       <RTRUE>)
			      (<COMPARE-WORD-TYPES <WCN .WD>
						 <GET-CLASSIFICATION PARTICLE>>
			       ;<WORD-TYPE? .WD ,P-PARTICLE-CODE>
			       <INSERT-WHAT .TMP <ZREST .SUBJ .END>>
			       <RTRUE>)
			      (<G? ,TLEXV <SET SUBJ
					       <ZBACK .SUBJ <* 2 ,P-LEXELEN>>>>
			       <SET END 0>
			       <RTRUE>)>>)>
	       T)>)>>

<DEFINE INSERT-WHAT (TMP SUBJ)
 <COND (<NOT <EQUAL? .TMP <ZGET <ZBACK .SUBJ 4> 0>>>
	<INSERT-ADJS-WD </ <- .SUBJ ,P-LEXV> 2> .TMP>
	;<SETG P-LEN <+ 1 ,P-LEN>>
	<SETG P-OLEN <+ 1 ,P-OLEN>>
	<COPY-INPUT 1>
	<SETG P-OFLAG 0>
	T)>>

;"<DEFINE SUB-PRSA () <PARSE-ACTION ,PARSE-RESULT>>
<DEFINE SUB-P-PRSO () <PARSE-OBJ1 ,PARSE-RESULT>>
<DEFINE SUB-P-PRSI () <PARSE-OBJ2 ,PARSE-RESULT>>
<DEFINE SUB-PRSO ('AUX' X)
 <COND (<AND <SET X <PARSE-OBJ1 ,PARSE-RESULT>>
	     <1? <NOUN-PHRASE-COUNT .X>>>
	<NOUN-PHRASE-OBJ1 .X>)>>
<DEFINE SUB-PRSI ('AUX' X)
 <COND (<AND <SET X <PARSE-OBJ2 ,PARSE-RESULT>>
	     <1? <NOUN-PHRASE-COUNT .X>>>
	<NOUN-PHRASE-OBJ1 .X>)>>"

<END-SEGMENT>
<ENDPACKAGE>
